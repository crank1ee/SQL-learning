WITH CTE_Employee AS
(Select firstname, LastName, Gender, salary, Count(gender) OVER (Partition BY Gender) AS TotalGender, AVG(salary) OVER (Partition BY Gender) AS AvgSalary
FROM [SQLTutorial].[dbo].[EmployeeDemographics] AS Demo
Join SQLTutorial.DBO.EmployeeSalary AS sal
ON demo.EmployeeID=sal.EmployeeID
Where Salary > '45000'
)
SELECT FirstName, LastName  -- like subquery
FROM CTE_Employee
Where Gender = 'Male'   -- This is temporary containter, that is not in memory. It does contain the contenct of query and we can select particular data from it

--temp tables----

Create Table #temp_Employee (   -- remember about #
EmployeeID int,
Jobtitle varchar(50),
Salary int
)
--Insert into #temp_Employee Values   ---manuall
--('1001','HR','45000')

Insert into #temp_Employee             -- insert from diffrent table (query)
Select*
FROM SQLTutorial.dbo.EmployeeSalary
--------
DROP TABLE IF EXISTS #temp_employee2             -- trick -> delete this table if it exists, becuase if it exist in temp we cannot create it again through procedure
Create Table #temp_Employee2 (
Jobtitle varchar(50),
EmployeesPerJob int,
AvgAge int,
AvgSalary int
)

Insert into #temp_Employee2 
Select Jobtitle, Count(jobtitle), Avg(age), AVG(salary)   ---- example procedure how  create temp table with preselected data in query
FROM SQLTutorial.dbo.EmployeeDemographics AS demo
JOIN SQLTutorial.dbo.EmployeeSalary AS sal
ON Demo.EmployeeID=sal.EmployeeID
Group by JobTitle

Select*
From #temp_Employee2            -- overall this usecase of temp table is also to get specific part of data from big database to reduce calculation and memory

-------functions--------
Select EmployeeID, RTrim(EmployeeID) AS IDTrimmed  -- Rtrim Ltrim or TRIM (trim spaces etc.)
From EmployeeErrors

Select LastName, REPLACE(LastName, '- Fired', '') as LastNameFixed  -- replace value with new one, blank in this case
From EmployeeErrors

Select SUBSTRING(FirstName,1,4) As FirstNameChanged -- FirstName is the column, 1 - is start sign (from which letter we start) 4- amount of letter to show
From EmployeeErrors

Select err.FirstName, SUBSTRING(err.FirstName,1,3) , dem.FirstName, Substring(dem.FirstName,1,3)   --Fuzzy matching - it is the matching two tables based on signs
From EmployeeErrors AS err                                              -- it is mostly used on fe. Gender/LastName/Age/DOB. Firstname is not good example
Join SQLTutorial.dbo.EmployeeDemographics AS dem
ON SUBSTRING(err.FirstName,1,3)=Substring(dem.FirstName,1,3)

Select FirstName, UPPER(FirstName)    -- upper or lower
From EmployeeErrors

-- This query will change first on Capital, rest on small letters. Left choose how many letters we pick, Len give result of legnht of string
Select FirstName, Lower(Firstname) As UpperName, UPPer(LEFT(FirstName,1))+Lower(Substring(Firstname,2,Len(Firstname))) AS Capitalfirst
From EmployeeErrors 

Update SQLTutorial.dbo.EmployeeErrors
SET FirstName = UPPer(LEFT(FirstName,1))+Lower(Substring(Firstname,2,Len(Firstname))) -- this updateing data inside the table from result of query
------------------

--Storage procedure-----
CREATE PROCEDURE Temp_Employee2  ---- it creates query that we can execute late. in this case creating temp table
AS
DROP TABLE IF EXISTS #temp_Employee2
Create Table #temp_Employee2 (
Jobtitle varchar(50),
EmployeesPerJob int,
AvgAge int,
AvgSalary int
)
Insert into #temp_Employee2 
Select Jobtitle, Count(jobtitle), Avg(age), AVG(salary)   ---- example procedure how  create temp table with preselected data in query
FROM SQLTutorial.dbo.EmployeeDemographics AS demo
JOIN SQLTutorial.dbo.EmployeeSalary AS sal
ON Demo.EmployeeID=sal.EmployeeID
Group by JobTitle

SELECT *
FROM #temp_Employee2
----till this point-----        
----Exec Temp_Employee2



